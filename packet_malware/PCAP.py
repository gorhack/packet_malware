"""
Assemble PCAP files and return hash of all carved files
"""

# Reading pcaps
from scapy.all import *
from scapy.utils import rdpcap
import scapy_http.http
import os

from datetime import datetime
import hashlib
import re

# Local classes
from Host import Host
from Files import Files
from PcapAnalyzer import PcapAnalyzer
import Grapher

# APIs
from GoogleSB import GSB  # 10k requests/24hrs
from Metadefender import Metadefender  # 1500 hashes/hr


def tcpflower(pcap_file, outdir='tcpflow_capture'):
    """
    Creates directory with all tcp streams from a pcap file in the
    specified output directory.
    """
    # follow tcp stream and scan for all objects
    if os.path.exists(tcpflow_outdir):
        print("Pcap already tested..running analysis\n")
    else:
        cmd = 'tcpflow -a -r {} -o {}'.format(pcap_file, outdir)
        p = os.popen(cmd).readlines()


def get_filenames(path):
    files = []
    for file in os.scandir(path):
        files.append(file.name)
        # # recursively get all files in path
        # if file.is_file():
        #     files.append(r'{}/{}'.format(path, file.name))
        # elif file.is_dir():
        #     files += get_filenames(r'{}/{}'.format(path, file.name))
        # else:
        #     pass
    return files


def hash_checker(hashes):
    print("Checking files for malware...")
    md = Metadefender()
    hashes = [Files('file1',
                         '28FD8C8B632EF4174F7C6ECBAA5A443A',
                         '1.1.1.1',
                         '80',
                         '2.2.2.2',
                         '80'),
                   Files('file2',
                         '4B64C29A75713788BB7116D97CEE41F4',
                         '3.3.3.3',
                         '80',
                         '5.5.5.5',
                         '80')]
    hashes_only = ['28FD8C8B632EF4174F7C6ECBAA5A443A',
                   '4B64C29A75713788BB7116D97CEE41F4']
    # for h in hashes:
    #     hashes_only.append(h.md5_sum)

    md.analyzeHashes(hashes_only)
    r = md.response

    count = 0
    for h, hash_resp in zip(hashes, r):
        result = hash_resp['scan_result']
        if result == 1 or result == 2:
            h.warning_level = 'high'
            count += 1
            print("    Infected File Found: {}".format(h.name) +
                  "\n      Hash: {}".format(h.md5_sum) +
                  "\n      Source IP/Port: {}:{}".format(h.srcip, h.srcport) +
                  "\n      Dest IP/Port: {}:{}".format(h.dstip, h.dstport))

    print("{} total files analyzed.".format(len(hashes_only)))
    print("{} infected files found.".format(count))
    print("="*78)


def host_checker(hosts):
    print("Checking for malicious hosts...")
    gsb = GSB()
    addrs = []
    url_re = re.compile('.*\..*$')  # super basic...

    for host in hosts:
        if url_re.match(host.hostname):
            addrs.append(host.hostname)
        else:
            addrs.append(host.ip)

    gsb.analyzeUrls(addrs)
    r = gsb.response.split('\n')
    count = 0
    for h, check in zip(hosts, r):
        if check == 'ok':
            pass
        else:
            h.warning_level = 'high'
            count += 1
            if h.ip == host.hostname:
                print("    Malicious URL/IP Found: {}".format(h.hostname))
            else:
                print("    Malicious URL/IP Found: {} ({})".format(h.hostname,
                                                                   h.ip))
        # print("{}: {}".format(host.hostname, host.warning_level))
    print("{} total URLs/IPs analyzed.".format(len(hosts)))
    print("{} malicious URLs/IPs found".format(count))


def examine_pkts(pcap_file):
    addrs = dict()
    local_hosts = dict()
    dns_servers = set()

    print("Reading pcap...")
    pkts = rdpcap(pcap_file)
    print("Examining pcap...")
    ip_re = re.compile("^\d{1,3}(\.\d{1,3}){3}$")
    for i, pkt in enumerate(pkts):
        try:
            if (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 1):
                # DHCP Lookups
                ip = pkt[IP].src
                hostname = ip

                relations = set()
                if addrs.get(ip):
                    hostname = addrs[ip][0]
                    relations = addrs[ip][1]

                try:
                    hostname = pkt[DHCP].options[2][1].decode('utf-8')
                except AttributeError as e:
                    continue

                local_hosts[ip] = hostname
                addrs[ip] = [hostname, relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].an):
                # Local DNS Resolution
                """
                rdata is IP address of remote server (REGEX to verify)
                rrname is the hostname of the remote server
                ip.dst is the IP requesting to resolve the server
                """

                ip = str(pkt[DNS].an.lastlayer().rdata)
                if ip_re.match(ip):  # check if IP resolved
                    hostname = pkt[DNS].an.lastlayer().rrname.decode('utf-8')[:-1]

                    relations = set()
                    if addrs.get(ip):
                        relations = addrs[ip][1]

                    relations.add(pkt.getlayer('IP').dst)

                    addrs[ip] = [hostname, relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].qd and
                    pkt[DNS].qd.getlayer('DNS Question Record') and
                    pkt[DNS].rcode == 0):
                dns_servers.add(pkt.getlayer('IP').dst)
            elif pkt.getlayer('IP'):
                # Add connections
                srcip = pkt[IP].src
                dstip = pkt[IP].dst

                hostname = srcip
                relations = set()

                if addrs.get(srcip):
                    hostname = addrs[srcip][0]
                    relations = addrs[srcip][1]

                relations.add(dstip)

                addrs[srcip] = [hostname, relations]
        except TypeError as e:
            continue

    hosts = []
    for k, v in addrs.items():
        hosts.append(Host(k, v[0], v[1]))
    # print("\n".join("{}: {}".format(k, v) for k, v in addrs.items()))
    print('='*78)
    host_checker(hosts)
    print('='*78)
    print("DNS Servers: {}".format(dns_servers))
    print("total unique local hosts: {}".format(len(local_hosts)))
    print("\n".join("    {}: {}".format(k, v) for k, v in local_hosts.items()))


def http_data_assembler(pcap_file, tcpflow_outdir):
    tcpflower(pcap_file, tcpflow_outdir)

    # have all file names
    files = get_filenames(tcpflow_outdir)
    # print(files)
    hashes = []
    for f in files:
        # regex to match */ip.ad.dr.ess.port-ip.ad.dr.ess.port-.*
        p = re.compile(".*\d{3}(\.\d{3}){3}\.\d{5}\-\d{3}(\.\d{3}){3}\.\d{5}\-")
        if p.match(f):
            import magic
            full_file_path = "{}/{}".format(tcpflow_outdir, f)
            type_test = magic.from_file(full_file_path)
            if b'text' not in type_test:
                with open(full_file_path, 'rb') as d_file:
                    data = d_file.read()
                    hashes.append(Files(  # name
                                  d_file.name.split(tcpflow_outdir, 1)[1][1:],
                                  hashlib.md5(data).hexdigest(),  # md5
                                  f[:15],  # src ip address
                                  f[16:21],  # src port
                                  f[22:37],  # dst ip address
                                  f[38:43]))  # dst port
    hash_checker(hashes)
    examine_pkts(pcap_file)


if __name__ == '__main__':
    print("="*78)
    import sys
    if len(sys.argv) < 2:
        print("Use: python PCAP.py [pcap] [outdir]\n")
        sys.exit(1)
    packet_path = sys.argv[1]
    if len(sys.argv) == 3:
        tcpflow_outdir = sys.argv[2]
    else:
        tcpflow_outdir = sys.argv[1] + '_output'
    # if os.path.exists(tcpflow_outdir):
    #     tcpflow_outdir += '_' + datetime.now().strftime("%Y.%m.%d.%H%M%S")
    http_data_assembler(packet_path, tcpflow_outdir)
    # Grapher.main()


# for i, sessions in enumerate(src):
#         # break pcap into streams and follow each stream
#         print('stream {}'.format(i))
#         print('=' * 78)
#         print(sessions)
#         # for k, v in session.iteritems():
#         #     for p in v:
#         #         print(p.time, k)
#         #     if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
#         #         print(pkt.getlayer(Raw).load)
#         count += 1

# dependencies: foremost, tcpflow, scapy, pyqt
# extracting tcp streams: tcpflow -r [pcap]
# file names IP addresses 000.000.000.000.00000-000.000.000.000.0000
# for file in tcpflow/ as tcpflow.out:
#   extracting files: foremost -i tcpflow.out
# for file in output/ as f:
#   hashfile = hash(f)
#   vuln = sendToScaner()
#   return (filename, hashfile, vuln)
# extracting IPs
# pkt.getlayer(IP).dst / src
# import socket
# domain = socket.gethostbyaddr([IP addr])[0]
# getting computer hostname
# pcap[119].getlayer('DHCP options').options[2] | pcap[119][IP].src

# vars to print:
    # files found
    # hash values of files
    # files that are vuln
    # IP and domain names
    # IP and domains that are vuln
