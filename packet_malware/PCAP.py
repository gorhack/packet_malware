"""
Assemble PCAP files and return hash of all carved files
"""

# Reading pcaps
from scapy.all import *
from scapy.utils import rdpcap
import scapy_http.http
import os

from datetime import datetime
import hashlib
import re

# Local classes
from Host import Host
from LocalHost import LocalHost
from Files import Files
from PcapAnalyzer import PcapAnalyzer
import Grapher

# APIs
from GoogleSB import GSB  # 10k requests/24hrs
from Metadefender import Metadefender  # 1500 hashes/hr


def tcpflower(pcap_file, outdir='tcpflow_capture'):
    """
    Creates directory with all tcp streams from a pcap file in the
    specified output directory.
    """
    # follow tcp stream and scan for all objects
    if os.path.exists(tcpflow_outdir):
        print("Pcap already tested..running analysis\n")
    else:
        cmd = 'tcpflow -a -r {} -o {}'.format(pcap_file, outdir)
        p = os.popen(cmd).readlines()


def get_filenames(path):
    files = []
    for file in os.scandir(path):
        files.append(file.name)
        # # recursively get all files in path
        # if file.is_file():
        #     files.append(r'{}/{}'.format(path, file.name))
        # elif file.is_dir():
        #     files += get_filenames(r'{}/{}'.format(path, file.name))
        # else:
        #     pass
    return files


def hash_checker(hashes):
    print("Checking files for malware...")
    md = Metadefender()

    md.analyzeHashes(list(hashes.keys()))
    r = md.response

    bad_files = []

    count = 0
    if len(r) > 0:
        for hash_resp in r:
            result = hash_resp['scan_result']
            result_hash = hash_resp['hash']

            h = hashes[result_hash]
            if result == 1:
                h.warning_level = 2
                count += 1
                # change all the hashes...
                print("  Infected File Found: {}".format(h.name) +
                      "\n    Type: {}".format(h.file_type) +
                      "\n    Hash: {}".format(h.md5_sum) +
                      "\n    Source IP/Port: {}:{}".format(h.srcip, h.srcport) +
                      "\n    Dest IP/Port: {}:{}".format(h.dstip, h.dstport))
            elif result == 2:
                h.warning_level = 1
                count += 1
                print("  Suspicious File Found: {}".format(h.name) +
                      "\n    Type: {}".format(h.file_type) +
                      "\n    Hash: {}".format(h.md5_sum) +
                      "\n    Source IP/Port: {}:{}".format(h.srcip, h.srcport) +
                      "\n    Dest IP/Port: {}:{}".format(h.dstip, h.dstport))

            bad_files.append(h)

    print("{} total files analyzed.".format(len(hashes)))
    print("{} infected files found.".format(count))
    print("="*78)
    return bad_files


def host_checker(hosts):
    print("Checking for malicious hosts...")
    gsb = GSB()
    addrs = []
    url_re = re.compile('.*\..*$')  # super basic...

    for ip, host in hosts.items():
        if url_re.match(host.hostname):
            addrs.append(host.hostname)
        else:
            addrs.append(ip)

    gsb.analyzeUrls(addrs)
    r = gsb.response.split('\n')
    count = 0
    if len(r) > 0 and r[0] != '':
        for h, check in zip(hosts.values(), r):
            if check == 'ok':
                pass
            else:
                h.warning_level = 1
                count += 1
                if h.ip == host.hostname:
                    print("  Malicious URL/IP Found: {}".format(h.hostname))
                else:
                    print("  Malicious URL/IP Found: {} ({})".format(h.hostname,
                                                                     h.ip))
        # print("{}: {}".format(host.hostname, host.warning_level))
    print("{} total URLs/IPs analyzed.".format(len(hosts)))
    print("{} malicious URLs/IPs found".format(count))


def examine_pkts(pcap_file):
    addrs = dict()  # ip : hostname, relations

    # ip: [MAC address, hostname, relations]
    requested_local_hosts = dict()  # requested_addr : (mac, hostname)
    local_hosts = dict()  # IP: [mac, hostname]
    dns_servers = set()

    print("Reading pcap...")
    pkts = rdpcap(pcap_file)
    print("Examining {} packets...".format(len(pkts)))
    ip_re = re.compile("^\d{1,3}(\.\d{1,3}){3}$")
    for i, pkt in enumerate(pkts):
        try:
            if (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 1):
                # DHCP REQUEST
                mac_addr = pkt.src
                hostname = ''
                ip = ''

                for t in pkt[DHCP].options:
                    if t[0] == 'hostname':
                        hostname = t[1].decode('utf-8', 'ignore')
                    elif t[0] == 'requested_addr':
                        requested_addr = t[1]

                ip = requested_addr

                # print("req: {} {} [{}]".format(ip, hostname, mac_addr))
                requested_local_hosts[ip] = [mac_addr, hostname]

            elif (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 2):
                # DHCP ACK
                ip = pkt[BOOTP].yiaddr
                hostname = ''

                for t in pkt[DHCP].options:
                    if t[0] == 'name_server':
                        dns_servers.add(t[1])

                if requested_local_hosts.get(ip):
                    req = requested_local_hosts[ip]
                    hostname = req[1]
                    local_hosts[ip] = [req[0], hostname]

                relations = set()
                if addrs.get(ip):
                    relations = addrs[ip][1]

                addrs[ip] = [hostname, relations]

            elif (pkt.getlayer('DNS') and pkt[DNS].an):
                # Local DNS Resolution
                """
                rdata is IP address of remote server (REGEX to verify)
                rrname is the hostname of the remote server
                ip.dst is the IP requesting to resolve the server
                """

                ip = str(pkt[DNS].an.lastlayer().rdata)
                if ip_re.match(ip):  # check if IP resolved
                    hostname = pkt[DNS].an.lastlayer().rrname.decode('utf-8',
                                                                     'ignore')[:-1]

                    relations = set()
                    if addrs.get(ip):
                        relations = addrs[ip][1]

                    relations.add(pkt.getlayer('IP').dst)

                    addrs[ip] = [hostname, relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].qd and
                    pkt[DNS].qd.getlayer('DNS Question Record') and
                    pkt[DNS].rcode == 0):
                dns_servers.add(pkt.getlayer('IP').dst)
            elif pkt.getlayer('IP'):
                # Add connections
                srcip = pkt[IP].src
                dstip = pkt[IP].dst

                hostname = srcip
                relations = set()

                # for source
                if addrs.get(srcip):
                    hostname = addrs[srcip][0]
                    relations = addrs[srcip][1]

                relations.add(dstip)

                # for destination
                dsthostname = dstip
                dstrelations = set()

                if addrs.get(dstip):
                    dsthostname = addrs[dstip][0]
                    dstrelations = addrs[dstip][1]

                dstrelations.add(srcip)

                addrs[srcip] = [hostname, relations]
                addrs[dstip] = [dsthostname, dstrelations]
        except TypeError as e:
            continue

    hosts = dict()
    for ip, vals in addrs.items():
        hosts[ip] = Host(ip, vals[0], vals[1])

    # print("\n".join("{}: {}".format(k, v) for k, v in addrs.items()))
    print('='*78)
    host_checker(hosts)
    print('='*78)
    print("DNS Servers: {}".format(dns_servers))
    print("{} Local hosts".format(len(local_hosts)))
    print("\n".join("    {}: {} [{}]".format(k, v[0], v[1]) for k, v in local_hosts.items()))

    return local_hosts, hosts


def analyzePcap(local_hosts, hosts, files):
    print("="*78)
    print("Analyzing network...")

    # find all malicious files
    malicious_files = []
    for f in files.values():
        if f.warning_level != 0:
            malicious_files.append(f)
            # change source warning levels

            if (hosts.get(f.srcip) and
                    f.warning_level > hosts[f.srcip].warning_level):
                hosts[f.srcip].warning_level = f.warning_level

    # get objects for local hosts
    _local_hosts = []  # LocalHost objects with Host info
    for ip, hn_mac in local_hosts.items():
        h = hosts[ip]
        _local_hosts.append(LocalHost(h.ip,
                                      hn_mac[0],
                                      hn_mac[1],
                                      h.related_urls))

    # find all malicious hosts
    malicious_hosts = dict()
    for h in hosts.values():
        if h.warning_level != 0:
            malicious_hosts[h.ip] = h

    # create Pcap Analyzer on local_hosts
    pcapAnalysis = []
    for h in _local_hosts:
        _ip = h.ip
        _mac_addr = h.mac_addr
        _hostname = h.hostname
        _related_urls = h.related_urls
        _relationships = []
        _malicious_cons = []
        _malicious_files = []
        _warning_level = h.warning_level

        for ip, mh in malicious_hosts.items():
            if _ip in mh.related_urls:
                _malicious_cons.append(mh)
                if mh.warning_level > _warning_level:
                    _warning_level = mh.warning_level

        for mf in malicious_files:
            if _ip == mf.srcip or _ip == mf.dstip:
                _malicious_files.append(mf)
                if mf.warning_level > _warning_level:
                    _warning_level = mf.warning_level

        for ip in _related_urls:
            _relationships.append(hosts[ip])

        pcapAnalysis.append(PcapAnalyzer(_ip,
                                         _mac_addr,
                                         _hostname,
                                         _relationships,
                                         _malicious_files,
                                         _warning_level))
        print("\n{} ({}) has warning level {}".format(_hostname,
                                                      _ip,
                                                      _warning_level))
        if _warning_level != 0:
            bad_cons = len(_malicious_cons)
            bad_files = len(_malicious_files)
            if bad_cons > 0:
                print("  Connected to {} malicious hosts:".format(bad_cons))
                for mc in _malicious_cons:
                    if mc.ip == mc.hostname:
                        print("    {}".format(mc.hostname))
                    else:
                        print("    {} ({})".format(mc.hostname,
                                                   mc.ip))
            if bad_files > 0:
                print("  Downloaded {} malicious files:".format(bad_files))
                for mf in _malicious_files:
                    print("    File: {}".format(mf.name) +
                          "\n      Type: {}".format(mf.file_type) +
                          "\n      Hash: {}".format(mf.md5_sum))

    return pcapAnalysis


def correctIP(ip):
    ip = ip.split('.')
    newip = ''
    for i in ip:
        if i.lstrip('0') == '':
            newip += '0.'
        else:
            newip += i.lstrip('0') + '.'

    return newip[:-1]


def http_data_assembler(pcap_file, tcpflow_outdir):
    tcpflower(pcap_file, tcpflow_outdir)

    # have all file names
    files = get_filenames(tcpflow_outdir)
    # print(files)
    hashes = dict()
    for f in files:
        # regex to match */ip.ad.dr.ess.port-ip.ad.dr.ess.port-.*
        p = re.compile(".*\d{3}(\.\d{3}){3}\.\d{5}\-\d{3}(\.\d{3}){3}\.\d{5}\-")
        if p.match(f):
            import magic
            full_file_path = "{}/{}".format(tcpflow_outdir, f)
            type_test = magic.from_file(full_file_path)
            # print(type_test)
            SKIP_FILES = [b'PNG', b'JPEG', b'GIF', b'icon']
            if not any(st in type_test for st in SKIP_FILES):
                with open(full_file_path, 'rb') as d_file:
                    data = d_file.read()
                    md5_hash = hashlib.md5(data).hexdigest().upper()
                    hashes[md5_hash] = Files(f,  # name
                                             type_test.decode('utf-8',
                                                              'ignore'),  # file type
                                             md5_hash,  # md5
                                             correctIP(f[:15]),  # src ip address
                                             f[16:21],  # src port
                                             correctIP(f[22:37]),  # dst ip address
                                             f[38:43])  # dst port
                    # print("{}: {}".format(f, type_test))

    hash_checker(hashes)
    local_hosts, hosts = examine_pkts(pcap_file)

    # now analyze hosts with files...
    analyzedPcap = analyzePcap(local_hosts, hosts, hashes)
    print("="*78)
    Grapher.graphPcap(analyzedPcap)


if __name__ == '__main__':
    print("="*78)
    import sys
    if len(sys.argv) < 2:
        print("Use: python PCAP.py [pcap] [outdir]\n")
        sys.exit(1)
    packet_path = sys.argv[1]
    if len(sys.argv) == 3:
        tcpflow_outdir = sys.argv[2]
    else:
        tcpflow_outdir = sys.argv[1] + '_output'
    # if os.path.exists(tcpflow_outdir):
    #     tcpflow_outdir += '_' + datetime.now().strftime("%Y.%m.%d.%H%M%S")
    http_data_assembler(packet_path, tcpflow_outdir)
    # Grapher.main()
