"""
Assemble PCAP files and return hash of all carved files
"""

from scapy.all import *
from scapy.utils import rdpcap
import scapy_http.http
import os
from datetime import datetime
import hashlib
import re


def tcpflower(pcap_file, outdir='tcpflow'):
    """
    Creates directory with all tcp streams from a pcap file in the
    specified output directory.
    """
    # follow tcp stream and scan for all objects
    cmd = 'tcpflow -a -r {} -o {}'.format(pcap_file, outdir)
    p = os.popen(cmd).readlines()


def get_filenames(path):
    files = []
    for file in os.scandir(path):
        files.append(file.name)
        # if file.is_file():
        #     files.append(r'{}/{}'.format(path, file.name))
        # elif file.is_dir():
        #     files += get_filenames(r'{}/{}'.format(path, file.name))
        # else:
        #     pass
    return files


def hash_checker(hashes):
    for h in hashes:
        print(h.md5_sum)


class Hosts(object):
    def __init__(self, ip, hostname, relationships, warning_level='None'):
        self.ip = ip
        self.hostname = hostname
        self.relationships = relationships
        self.warning_level = warning_level


class PpTest(object):
    def __init__(self, md5_sum, srcip, srcport, dstip, dstport):
        self.md5_sum = md5_sum
        self.virus = ''
        self.srcip = srcip
        self.srcport = srcport
        self.dstip = dstip
        self.dstport = dstport
        self.warning_level = 'None'  # None, Low, Medium, High


def http_data_assembler(pcap_file, tcpflow_outdir):
    total_objects = 0
    addrs = set()

    tcpflower(pcap_file, tcpflow_outdir)

    # foremost to analyze files
    # current_date = datetime.now().strftime("%Y.%m.%d.%H%M%S")
    # foremost_outdir = "output_{}".format(current_date)
    # cmd = 'foremost -o {} -i {}/*'.format(foremost_outdir, tcpflow_outdir)
    # p = os.popen(cmd).readlines()

    # have all file names
    files = get_filenames(tcpflow_outdir)
    # print(files)
    hashes = []
    for f in files:
        addrs.add(f[:15])
        addrs.add(f[22:37])
        # regex to match */ip.ad.dr.ess.port-ip.ad.dr.ess.port-.*
        p = re.compile(".*\d{3}(\.\d{3}){3}\.\d{5}\-\d{3}(\.\d{3}){3}\.\d{5}\-")
        if p.match(f):
            with open("{}/{}".format(tcpflow_outdir, f), 'rb') as d_file:
                data = d_file.read()
                hashes.append(PpTest(hashlib.md5(data).hexdigest(),
                           f[:15],  # src ip address
                           f[16:21],  # src port
                           f[22:37],  # dst ip address
                           f[38:43]))  # dst port
    hash_checker(hashes)


    # src = rdpcap(pcap_file)
    # s = src.sessions()
    # for k, v in s.items():
    #     tot_packets = len(v)
    #     #print('{}\n'.format(v.hexraw().encode('HEX')))
    #     if "TCP" in k:
    #         proto, source, flurp, target = k.split()
    #         srcip, srcport = source.split(":")
    #         dstip, dstport = target.split(":")
        #print('{}:{} => {}:{}'.format(srcip, srcport, dstip, dstport))
        # for packet in sessions[session]:
        #     try:
        #         if packet[TCP].dport == 80 or packet[TCP].sport == 80:
        #             http_payload += str(packet[TCP].payload)
        #     except:
        #         pass
        #     headers = get_http_headers(http_payload)
        #     print(headers)
    # count = 0
    # for i, pkt in enumerate(src):
    #     if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
    #         print('=' * 78)
    #         print('packet {}'.format(i))
    #         print(pkt.getlayer(Raw).load)
    #         count += 1
    # print('total objects: {}'.format(count))

if __name__ == '__main__':
    import sys
    if len(sys.argv) != 3:
        print("Use: python PCAP.py [pcap] [outdir]\n")
        sys.exit(1)
    packet_path = sys.argv[1]
    tcpflow_outdir = sys.argv[2]
    if os.path.exists(tcpflow_outdir):
        tcpflow_outdir += '_' + datetime.now().strftime("%Y.%m.%d.%H%M%S")
    http_data_assembler(packet_path, tcpflow_outdir)

# for i, sessions in enumerate(src):
#         # break pcap into streams and follow each stream
#         print('stream {}'.format(i))
#         print('=' * 78)
#         print(sessions)
#         # for k, v in session.iteritems():
#         #     for p in v:
#         #         print(p.time, k)
#         #     #if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
#         #     #    print(pkt.getlayer(Raw).load)
#         count += 1

# dependencies: foremost, tcpflow, scapy, pyqt
# extracting tcp streams: tcpflow -r [pcap]
# file names IP addresses 000.000.000.000.00000-000.000.000.000.0000
# for file in tcpflow/ as tcpflow.out:
#   extracting files: foremost -i tcpflow.out
# for file in output/ as f:
#   hashfile = hash(f)
#   vuln = sendToScaner()
#   return (filename, hashfile, vuln)
# extracting IPs
# pkt.getlayer(IP).dst / src
# import socket
# domain = socket.gethostbyaddr([IP addr])[0]

# vars to print:
    # files found
    # hash values of files
    # files that are vuln
    # IP and domain names
    # IP and domains that are vuln
