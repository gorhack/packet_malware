"""
Assemble PCAP files and return hash of all carved files
"""

from scapy.all import *
from scapy.utils import rdpcap
import scapy_http.http
import os
from datetime import datetime
import hashlib


def tcpflower(pcap_file, outdir='tcpflow'):
    """
    Creates directory with all tcp streams from a pcap file in the
    specified output directory.
    """
    cmd = 'tcpflow -r {} -o {}'.format(pcap_file, outdir)
    p = os.popen(cmd).readlines()


def get_filenames(path):
    files = []
    for file in os.scandir(path):
        if file.is_file():
            files.append(r'{}/{}'.format(path, file.name))
        elif file.is_dir():
            files += get_filenames(r'{}/{}'.format(path, file.name))
        else:
            pass
    return files


def hash_checker(hashes):
    print(hashes)


def http_assembler(pcap_file, tcpflow_outdir):
    tcpflower(pcap_file, tcpflow_outdir)

    # foremost to analyze files
    current_date = datetime.now().strftime("%Y.%m.%d.%H%M%S")
    foremost_outdir = "output_{}".format(current_date)
    cmd = 'foremost -o {} -i {}/*'.format(foremost_outdir, tcpflow_outdir)
    p = os.popen(cmd).readlines()

    # have all file names
    files = get_filenames(foremost_outdir)
    print(files)
    hashes = []
    for file in files:
        print(file)
        with open(file, 'rb') as f:
            data = f.read()
            hashes.append(hashlib.md5(data).hexdigest())
    hash_checker(hashes)


    # src = rdpcap(pcap_file)
    # s = src.sessions()
    # for k, v in s.items():
    #     tot_packets = len(v)
    #     #print('{}\n'.format(v.hexraw().encode('HEX')))
    #     if "TCP" in k:
    #         proto, source, flurp, target = k.split()
    #         srcip, srcport = source.split(":")
    #         dstip, dstport = target.split(":")
        #print('{}:{} => {}:{}'.format(srcip, srcport, dstip, dstport))
        # for packet in sessions[session]:
        #     try:
        #         if packet[TCP].dport == 80 or packet[TCP].sport == 80:
        #             http_payload += str(packet[TCP].payload)
        #     except:
        #         pass
        #     headers = get_http_headers(http_payload)
        #     print(headers)
    # count = 0
    # for i, pkt in enumerate(src):
    #     if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
    #         print('=' * 78)
    #         print('packet {}'.format(i))
    #         print(pkt.getlayer(Raw).load)
    #         count += 1
    # print('total objects: {}'.format(count))

if __name__ == '__main__':
    import sys
    if len(sys.argv) != 3:
        print("Use: python PCAP.py [pcap] [outdir]\n")
        sys.exit(1)
    packet_path = sys.argv[1]
    tcpflow_outdir = sys.argv[2]
    if os.path.exists(tcpflow_outdir):
        tcpflow_outdir += '_' + datetime.now().strftime("%Y.%m.%d.%H%M%S")
    http_assembler(packet_path, tcpflow_outdir)

# for i, sessions in enumerate(src):
#         # break pcap into streams and follow each stream
#         print('stream {}'.format(i))
#         print('=' * 78)
#         print(sessions)
#         # for k, v in session.iteritems():
#         #     for p in v:
#         #         print(p.time, k)
#         #     #if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
#         #     #    print(pkt.getlayer(Raw).load)
#         count += 1

# dependencies: foremost, tcpflow, scapy, pyqt
# extracting tcp streams: tcpflow -r [pcap]
# file names IP addresses 000.000.000.000.00000-000.000.000.000.0000
# for file in tcpflow/ as tcpflow.out:
#   extracting files: foremost -i tcpflow.out
# for file in output/ as f:
#   hashfile = hash(f)
#   vuln = sendToScaner()
#   return (filename, hashfile, vuln)
# extracting IPs
# pkt.getlayer(IP).dst / src
# import socket
# domain = socket.gethostbyaddr([IP addr])[0]

# vars to print:
    # files found
    # hash values of files
    # files that are vuln
    # IP and domain names
    # IP and domains that are vuln
