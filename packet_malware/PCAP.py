"""
Assemble PCAP files and return hash of all carved files
"""

# Reading pcaps
from scapy.all import *
from scapy.utils import rdpcap
import scapy_http.http
import os

from datetime import datetime
import hashlib
import re

# Local classes
from Host import Host
from Files import Files
from PcapAnalyzer import PcapAnalyzer
import Grapher

# APIs
from GoogleSB import GSB  # 10k requests/24hrs
from Metadefender import Metadefender  # 1500 hashes/hr


def tcpflower(pcap_file, outdir='tcpflow_capture'):
    """
    Creates directory with all tcp streams from a pcap file in the
    specified output directory.
    """
    # follow tcp stream and scan for all objects
    if os.path.exists(tcpflow_outdir):
        print("Pcap already tested..running analysis\n")
    else:
        cmd = 'tcpflow -a -r {} -o {}'.format(pcap_file, outdir)
        p = os.popen(cmd).readlines()


def get_filenames(path):
    files = []
    for file in os.scandir(path):
        files.append(file.name)
        # # recursively get all files in path
        # if file.is_file():
        #     files.append(r'{}/{}'.format(path, file.name))
        # elif file.is_dir():
        #     files += get_filenames(r'{}/{}'.format(path, file.name))
        # else:
        #     pass
    return files


def hash_checker(hashes):
    print("Checking files for malware...")
    md = Metadefender()

    hashes_only = []
    for h in hashes:
        hashes_only.append(h.md5_sum)

    md.analyzeHashes(hashes_only)
    r = md.response

    bad_files = []

    count = 0
    import json
    for h, hash_resp in zip(hashes, json.loads(r)):
        result = hash_resp['scan_result']
        if result == 1:
            h.warning_level = 2
            count += 1
            print("    Infected File Found: {}".format(h.name) +
                  "\n      Hash: {}".format(h.md5_sum) +
                  "\n      Source IP/Port: {}:{}".format(h.srcip, h.srcport) +
                  "\n      Dest IP/Port: {}:{}".format(h.dstip, h.dstport) +
                  "\n      Stream: {}".format(h.stream))
        elif result == 2:
            h.warning_level = 1
            count += 1
            print("    Suspicious File Found: {}".format(h.name) +
                  "\n      Hash: {}".format(h.md5_sum) +
                  "\n      Source IP/Port: {}:{}".format(h.srcip, h.srcport) +
                  "\n      Dest IP/Port: {}:{}".format(h.dstip, h.dstport) +
                  "\n      Stream: {}".format(h.stream))

        bad_files.append(h)

    print("{} total files analyzed.".format(len(hashes_only)))
    print("{} infected files found.".format(count))
    print("="*78)
    return bad_files


def host_checker(hosts):
    print("Checking for malicious hosts...")
    gsb = GSB()
    addrs = []
    url_re = re.compile('.*\..*$')  # super basic...

    for host in hosts.values():
        if url_re.match(host.hostname):
            addrs.append(host.hostname)
        else:
            addrs.append(host.ip)

    gsb.analyzeUrls(addrs)
    r = gsb.response.split('\n')
    count = 0
    if len(r) > 0 and r[0] != '':
        for h, check in zip(hosts.values(), r):
            if check == 'ok':
                pass
            else:
                h.warning_level = 2
                count += 1
                if h.ip == host.hostname:
                    print("    Malicious URL/IP Found: {}".format(h.hostname))
                else:
                    print("    Malicious URL/IP Found: {} ({})".format(h.hostname,
                                                                   h.ip))
        # print("{}: {}".format(host.hostname, host.warning_level))
    print("{} total URLs/IPs analyzed.".format(len(hosts)))
    print("{} malicious URLs/IPs found".format(count))


def examine_pkts(pcap_file):
    addrs = dict()
    local_hosts = dict()
    dns_servers = set()

    print("Reading pcap...")
    pkts = rdpcap(pcap_file)
    print("Examining {} packets...".format(len(pkts)))
    ip_re = re.compile("^\d{1,3}(\.\d{1,3}){3}$")
    for pkt in pkts:
        try:
            if (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 1):
                # DHCP Lookups
                ip = pkt[IP].src
                hostname = ip

                relations = set()
                if addrs.get(ip):
                    hostname = addrs[ip][0]
                    relations = addrs[ip][1]

                try:
                    hostname = pkt[DHCP].options[2][1].decode('utf-8')
                except AttributeError as e:
                    continue

                local_hosts[ip] = hostname
                addrs[ip] = [hostname, relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].an):
                # Local DNS Resolution
                """
                rdata is IP address of remote server (REGEX to verify)
                rrname is the hostname of the remote server
                ip.dst is the IP requesting to resolve the server
                """

                ip = str(pkt[DNS].an.lastlayer().rdata)
                if ip_re.match(ip):  # check if IP resolved
                    hostname = pkt[DNS].an.lastlayer().rrname.decode('utf-8')[:-1]

                    relations = set()
                    if addrs.get(ip):
                        relations = addrs[ip][1]

                    relations.add(pkt.getlayer('IP').dst)

                    addrs[ip] = [hostname, relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].qd and
                    pkt[DNS].qd.getlayer('DNS Question Record') and
                    pkt[DNS].rcode == 0):
                dns_servers.add(pkt.getlayer('IP').dst)
            elif pkt.getlayer('IP'):
                # Add connections
                srcip = pkt[IP].src
                dstip = pkt[IP].dst

                hostname = srcip
                relations = set()

                # for source
                if addrs.get(srcip):
                    hostname = addrs[srcip][0]
                    relations = addrs[srcip][1]

                relations.add(dstip)

                # for destination
                dsthostname = dstip
                dstrelations = set()

                if addrs.get(dstip):
                    dsthostname = addrs[dstip][0]
                    dstrelations = addrs[dstip][1]

                dstrelations.add(srcip)

                addrs[srcip] = [hostname, relations]
                addrs[dstip] = [dsthostname, dstrelations]
        except TypeError as e:
            continue

    hosts = dict()
    for k, v in addrs.items():
        hosts[k] = Host(k, v[0], v[1])

    # print("\n".join("{}: {}".format(k, v) for k, v in addrs.items()))
    print('='*78)
    host_checker(hosts)
    print('='*78)
    print("DNS Servers: {}".format(dns_servers))
    print("{} Local hosts".format(len(local_hosts)))
    print("\n".join("    {}: {}".format(k, v) for k, v in local_hosts.items()))

    return local_hosts, hosts


def analyzePcap(local_hosts, hosts, files):
    print("="*78)
    print("Analyzing network...")

    # find all malicious files
    malicious_files = []
    for f in files:
        if f.warning_level != 0:
            malicious_files.append(f)
            # change source warning levels

            if (hosts.get(f.srcip) and
                    f.warning_level > hosts[f.srcip].warning_level):
                hosts[f.srcip].warning_level = f.warning_level

    # get objects for local hosts
    _local_hosts = []  # Host objects for local hosts
    for ip in local_hosts:
        _local_hosts.append(hosts.get(ip))

    # find all malicious hosts
    malicious_hosts = dict()
    for h in hosts.values():
        if h.warning_level != 0:
            malicious_hosts[h.ip] = h

    # create Pcap Analyzer on local_hosts
    pcapAnalysis = []
    for h in _local_hosts:
        _ip = h.ip
        _hostname = h.hostname
        _related_urls = h.related_urls
        _relationships = []
        _malicious_cons = []
        _malicious_files = []
        _warning_level = h.warning_level


        for ip, mh in malicious_hosts.items():
            if _ip in mh.related_urls:
                # _malicious_cons.append(mh)
                if mh.warning_level > _warning_level:
                    _warning_level = mh.warning_level

        for mf in malicious_files:
            if _ip == mf.srcip or _ip == mf.dstip:
                _malicious_files.append(mf)
                if mf.warning_level > _warning_level:
                    _warning_level = mf.warning_level

        for ip in _related_urls:
            _relationships.append(hosts[ip])

        pcapAnalysis.append(PcapAnalyzer(_ip,
                                         _hostname,
                                         _relationships,
                                         _malicious_files,
                                         _warning_level))
        print("\n{} ({}) has a {} warning level.".format(_hostname,
                                                         _ip,
                                                         _warning_level))
        if _warning_level != 0:
            bad_cons = len(_malicious_cons)
            bad_files = len(_malicious_files)
            if bad_cons > 0:
                print("  Connected to {} malicious hosts:".format(bad_cons))
                for mc in _malicious_cons:
                    if mc.ip == mc.hostname:
                        print("    {}".format(mc.hostname))
                    else:
                        print("    {} ({})".format(mc.hostname,
                                                   mc.ip))
            if bad_files > 0:
                print("  Downloaded {} malicious files:".format(bad_files))
                for mf in _malicious_files:
                    print("    {}\n    {}".format(mf.name, mf.md5_sum))

    return pcapAnalysis


def http_data_assembler(pcap_file, tcpflow_outdir):
    tcpflower(pcap_file, tcpflow_outdir)

    # have all file names
    files = get_filenames(tcpflow_outdir)
    # print(files)
    hashes = []
    for i, f in enumerate(files):
        # regex to match */ip.ad.dr.ess.port-ip.ad.dr.ess.port-.*
        p = re.compile(".*\d{3}(\.\d{3}){3}\.\d{5}\-\d{3}(\.\d{3}){3}\.\d{5}\-")
        if p.match(f):
            import magic
            full_file_path = "{}/{}".format(tcpflow_outdir, f)
            type_test = magic.from_file(full_file_path)
            # print(type_test)
            SKIP_FILES = [b'text', b'PNG', b'JPEG', b'GIF', b'icon']
            if not any(st in type_test for st in SKIP_FILES):
                with open(full_file_path, 'rb') as d_file:
                    data = d_file.read()
                    hashes.append(Files(f,  # name
                                  hashlib.md5(data).hexdigest(),  # md5
                                  f[:15],  # src ip address
                                  f[16:21],  # src port
                                  f[22:37],  # dst ip address
                                  f[38:43],  # dst port
                                  i))  # stream #
                    # print("{}: {}".format(f, type_test))
    bad_hashes = hash_checker(hashes)
    local_hosts, hosts = examine_pkts(pcap_file)

    # now analyze hosts with files...
    analyzedHosts = analyzePcap(local_hosts, hosts, hashes)
    print("="*78)
    Grapher.graphPcap(analyzedHosts)


if __name__ == '__main__':
    print("="*78)
    import sys
    if len(sys.argv) < 2:
        print("Use: python PCAP.py [pcap] [outdir]\n")
        sys.exit(1)
    packet_path = sys.argv[1]
    if len(sys.argv) == 3:
        tcpflow_outdir = sys.argv[2]
    else:
        tcpflow_outdir = sys.argv[1] + '_output'
    # if os.path.exists(tcpflow_outdir):
    #     tcpflow_outdir += '_' + datetime.now().strftime("%Y.%m.%d.%H%M%S")
    http_data_assembler(packet_path, tcpflow_outdir)
    # Grapher.main()
