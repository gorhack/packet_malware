"""
Assemble PCAP files and return hash of all carved files
"""

from scapy.all import *
from scapy.utils import rdpcap
import scapy_http.http
import os
from datetime import datetime
import hashlib
import re


def tcpflower(pcap_file, outdir='tcpflow'):
    """
    Creates directory with all tcp streams from a pcap file in the
    specified output directory.
    """
    # follow tcp stream and scan for all objects
    cmd = 'tcpflow -a -r {} -o {}'.format(pcap_file, outdir)
    p = os.popen(cmd).readlines()


def get_filenames(path):
    files = []
    for file in os.scandir(path):
        files.append(file.name)
        # if file.is_file():
        #     files.append(r'{}/{}'.format(path, file.name))
        # elif file.is_dir():
        #     files += get_filenames(r'{}/{}'.format(path, file.name))
        # else:
        #     pass
    return files


def hash_checker(hashes):
    for h in hashes:
        print(h.md5_sum)

def ip2hostname(pkt):
    if pkt.getlayer('DNS') and pkt[DNS].an:
            return (pkt[DNS].an.lastlayer().rdata,
                    pkt[DNS].an.lastlayer().rrname.decode('utf-8'))
    else:
        return None



class Hosts(object):
    def __init__(self, ip, hostname, relationships, warning_level='None'):
        self.ip = ip
        self.hostname = hostname
        self.relationships = relationships
        self.warning_level = warning_level


class PpTest(object):
    def __init__(self, md5_sum, srcip, srcport, dstip, dstport):
        self.md5_sum = md5_sum
        self.virus = ''
        self.srcip = srcip
        self.srcport = srcport
        self.dstip = dstip
        self.dstport = dstport
        self.warning_level = 'None'  # None, Low, Medium, High


def http_data_assembler(pcap_file, tcpflow_outdir):
    total_objects = 0
    addrs = dict()

    tcpflower(pcap_file, tcpflow_outdir)

    # foremost to analyze files
    # current_date = datetime.now().strftime("%Y.%m.%d.%H%M%S")
    # foremost_outdir = "output_{}".format(current_date)
    # cmd = 'foremost -o {} -i {}/*'.format(foremost_outdir, tcpflow_outdir)
    # p = os.popen(cmd).readlines()

    # have all file names
    files = get_filenames(tcpflow_outdir)
    # print(files)
    hashes = []
    for f in files:
        if f == 'report.xml':
            break

        # regex to match */ip.ad.dr.ess.port-ip.ad.dr.ess.port-.*
        p = re.compile(".*\d{3}(\.\d{3}){3}\.\d{5}\-\d{3}(\.\d{3}){3}\.\d{5}\-")
        if p.match(f):
            with open("{}/{}".format(tcpflow_outdir, f), 'rb') as d_file:
                data = d_file.read()
                hashes.append(PpTest(hashlib.md5(data).hexdigest(),
                              f[:15],  # src ip address
                              f[16:21],  # src port
                              f[22:37],  # dst ip address
                              f[38:43]))  # dst port
    hash_checker(hashes)

    pkts = rdpcap(pcap_file)
    ip_re = re.compile("^\d{1,3}(\.\d{1,3}){3}$")
    for i, pkt in enumerate(pkts):
        # ### HOSTNAME ####
        # DHCP TAKES PRIORITY
        # THEN LOCAL
        # THEN OUTSIDE DNS

        try:
            if (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 1):
                # DHCP Lookups
                ip = pkt[IP].src
                hostname = ip

                relations = set()
                if addrs.get(ip):
                    hostname = addrs[ip][0]
                    relations = addrs[ip][1]

                try:
                    hostname = pkt[DHCP].options[2][1].decode('utf-8')
                except AttributeError as e:
                    continue
                addrs[pkt[IP].src] = [hostname,
                                      relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].an):
                # Local DNS Resolution
                """
                rdata is IP address of remote server (REGEX to verify)
                rrname is the hostname of the remote server
                ip.dst is the IP requesting to resolve the server
                """

                print("DNS {}".format(i))
                ip = str(pkt[DNS].an.lastlayer().rdata)
                print("IP " + ip)
                if ip_re.match(ip):  # check if IP resolved
                    hostname = pkt[DNS].an.lastlayer().rrname.decode('utf-8')
                    print("matched! {}".format(hostname))

                    relations = set()
                    if addrs.get(ip):
                        relations = addrs[ip][1]
                        if pkt.getlayer('IP'):
                            relations.add(pkt[IP].dst)

                    addrs[ip] = [hostname, relations]
            elif pkt.getlayer('IP') and pkt.getlayer('TCP'):
                srcip = pkt[IP].src
                dstip = pkt[IP].dst

                hostname = srcip
                relations = set()

                if addrs.get(srcip):
                    hostname = addrs[srcip][0]
                    relations = addrs[srcip][1]
                    relations.add(dstip)

                addrs[srcip] = [hostname, relations]
        except TypeError as e:
            continue

        # elif pkt.getlayer('IP') and not addrs.get(pkt[IP].src):
        #     pass
        # # None, add relationship
        # else:
        #     pass
        # Outside resolution

        # ip_host = ip2hostname(pkt)
        # if ip_host and addrs.get(ip_host[0]):
        #     print(ip_host[1])
        #     print(addrs[srcip])
        #     addrs[srcip][0] = ip_host[1]

    print("\n".join("{}: {}".format(k, v[0]) for k, v in addrs.items()))
    print('='*78)
    print("total unique IPs: {}".format(len(addrs)))

    # hosts = []
    # for k, v in addrs.items():
    #     if k == v[0]:
    #         try:
    #             v[0] = socket.gethostbyaddr(k)[0]
    #         except socket.error:
    #             pass
    #         hosts.append(Hosts(k,
    #                            v[0],
    #                            v[1]))

    # print("{" + "\n".join("{}: {}".format(k, v) for k, v in addrs.items()) + "}")
    # print('='*78)

    # for h in hosts:
    #     print(h.hostname)

    # src = rdpcap(pcap_file)
    # s = src.sessions()
    # for k, v in s.items():
    #     tot_packets = len(v)
    #     #print('{}\n'.format(v.hexraw().encode('HEX')))
    #     if "TCP" in k:
    #         proto, source, flurp, target = k.split()
    #         srcip, srcport = source.split(":")
    #         dstip, dstport = target.split(":")
        #print('{}:{} => {}:{}'.format(srcip, srcport, dstip, dstport))
        # for packet in sessions[session]:
        #     try:
        #         if packet[TCP].dport == 80 or packet[TCP].sport == 80:
        #             http_payload += str(packet[TCP].payload)
        #     except:
        #         pass
        #     headers = get_http_headers(http_payload)
        #     print(headers)
    # count = 0
    # for i, pkt in enumerate(src):
    #     if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
    #         print('=' * 78)
    #         print('packet {}'.format(i))
    #         print(pkt.getlayer(Raw).load)
    #         count += 1
    # print('total objects: {}'.format(count))

if __name__ == '__main__':
    import sys
    if len(sys.argv) != 3:
        print("Use: python PCAP.py [pcap] [outdir]\n")
        sys.exit(1)
    packet_path = sys.argv[1]
    tcpflow_outdir = sys.argv[2]
    if os.path.exists(tcpflow_outdir):
        tcpflow_outdir += '_' + datetime.now().strftime("%Y.%m.%d.%H%M%S")
    http_data_assembler(packet_path, tcpflow_outdir)

# for i, sessions in enumerate(src):
#         # break pcap into streams and follow each stream
#         print('stream {}'.format(i))
#         print('=' * 78)
#         print(sessions)
#         # for k, v in session.iteritems():
#         #     for p in v:
#         #         print(p.time, k)
#         #     #if pkt.haslayer(TCP) and pkt.getlayer(TCP).sport == 80 and pkt.haslayer(Raw):
#         #     #    print(pkt.getlayer(Raw).load)
#         count += 1

# dependencies: foremost, tcpflow, scapy, pyqt
# extracting tcp streams: tcpflow -r [pcap]
# file names IP addresses 000.000.000.000.00000-000.000.000.000.0000
# for file in tcpflow/ as tcpflow.out:
#   extracting files: foremost -i tcpflow.out
# for file in output/ as f:
#   hashfile = hash(f)
#   vuln = sendToScaner()
#   return (filename, hashfile, vuln)
# extracting IPs
# pkt.getlayer(IP).dst / src
# import socket
# domain = socket.gethostbyaddr([IP addr])[0]
# getting computer hostname
# pcap[119].getlayer('DHCP options').options[2] | pcap[119][IP].src

# vars to print:
    # files found
    # hash values of files
    # files that are vuln
    # IP and domain names
    # IP and domains that are vuln
