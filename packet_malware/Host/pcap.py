from scapy.all import *
from scapy.utils import rdpcap
from . import Host
from . import LocalHost
from . import PcapAnalyzer

def to_hosts(pcap_file):
    addrs = dict()  # ip : hostname, relations

    # ip: [MAC address, hostname, relations]
    requested_local_hosts = dict()  # requested_addr : (mac, hostname)
    local_hosts = dict()  # IP: [mac, hostname]
    dns_servers = set()

    print("Reading pcap...")
    pkts = rdpcap(pcap_file)
    print("Examining {} packets...".format(len(pkts)))
    ip_re = re.compile("^\d{1,3}(\.\d{1,3}){3}$")
    for i, pkt in enumerate(pkts):
        try:
            if (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 1):
                # DHCP REQUEST
                mac_addr = pkt.src
                hostname = ''
                ip = ''

                for t in pkt[DHCP].options:
                    if t[0] == 'hostname':
                        hostname = t[1].decode('utf-8', 'ignore')
                    elif t[0] == 'requested_addr':
                        requested_addr = t[1]

                ip = requested_addr

                # print("req: {} {} [{}]".format(ip, hostname, mac_addr))
                requested_local_hosts[ip] = [mac_addr, hostname]

            elif (pkt.getlayer('IP') and pkt.getlayer('DHCP options') and
                    pkt.getlayer('BOOTP') and pkt[BOOTP].op == 2):
                # DHCP ACK
                ip = pkt[BOOTP].yiaddr
                hostname = ''

                for t in pkt[DHCP].options:
                    if t[0] == 'name_server':
                        dns_servers.add(t[1])

                if requested_local_hosts.get(ip):
                    req = requested_local_hosts[ip]
                    hostname = req[1]
                    local_hosts[ip] = [req[0], hostname]

                relations = set()
                if addrs.get(ip):
                    relations = addrs[ip][1]

                addrs[ip] = [hostname, relations]

            elif (pkt.getlayer('DNS') and pkt[DNS].an):
                # Local DNS Resolution
                """
                rdata is IP address of remote server (REGEX to verify)
                rrname is the hostname of the remote server
                ip.dst is the IP requesting to resolve the server
                """

                ip = str(pkt[DNS].an.lastlayer().rdata)
                if ip_re.match(ip):  # check if IP resolved
                    hostname = pkt[DNS].an.lastlayer().rrname.decode('utf-8',
                                                                     'ignore')[:-1]

                    relations = set()
                    if addrs.get(ip):
                        relations = addrs[ip][1]

                    relations.add(pkt.getlayer('IP').dst)

                    addrs[ip] = [hostname, relations]
            elif (pkt.getlayer('DNS') and pkt[DNS].qd and
                    pkt[DNS].qd.getlayer('DNS Question Record') and
                    pkt[DNS].rcode == 0):
                dns_servers.add(pkt.getlayer('IP').dst)
            elif pkt.getlayer('IP'):
                # Add connections
                srcip = pkt[IP].src
                dstip = pkt[IP].dst

                hostname = srcip
                relations = set()

                # for source
                if addrs.get(srcip):
                    hostname = addrs[srcip][0]
                    relations = addrs[srcip][1]

                relations.add(dstip)

                # for destination
                dsthostname = dstip
                dstrelations = set()

                if addrs.get(dstip):
                    dsthostname = addrs[dstip][0]
                    dstrelations = addrs[dstip][1]

                dstrelations.add(srcip)

                addrs[srcip] = [hostname, relations]
                addrs[dstip] = [dsthostname, dstrelations]
        except TypeError as e:
            continue

    hosts = dict()
    for ip, vals in addrs.items():
        hosts[ip] = Host(ip, vals[0], vals[1])

    resp = ("{} Local hosts\n".format(len(local_hosts)) +
            "\n".join("    {}: {} [{}]".format(k, v[0], v[1]) for k, v in local_hosts.items()))

    return (resp, local_hosts, dns_servers, hosts)


def analyze(local_hosts, hosts, files):
    print("Analyzing network...")

    resp = 'Local Host analysis:\n'

    # find all malicious files
    malicious_files = []
    for f in files.values():
        if f.warning_level != 0:
            malicious_files.append(f)
            # change source warning levels

            if (hosts.get(f.srcip) and
                    f.warning_level > hosts[f.srcip].warning_level):
                hosts[f.srcip].warning_level = f.warning_level

    # get objects for local hosts
    _local_hosts = []  # LocalHost objects with Host info
    for ip, hn_mac in local_hosts.items():
        h = hosts[ip]
        _local_hosts.append(LocalHost(h.ip,
                                      hn_mac[0],
                                      hn_mac[1],
                                      h.related_urls))

    # find all malicious hosts
    malicious_hosts = dict()
    for h in hosts.values():
        if h.warning_level != 0:
            malicious_hosts[h.ip] = h

    # create Pcap Analyzer on local_hosts
    pcapAnalysis = []
    for h in _local_hosts:
        _ip = h.ip
        _mac_addr = h.mac_addr
        _hostname = h.hostname
        _related_urls = h.related_urls
        _relationships = []
        _malicious_cons = []
        _malicious_files = []
        _warning_level = h.warning_level

        for ip, mh in malicious_hosts.items():
            if _ip in mh.related_urls:
                _malicious_cons.append(mh)
                if mh.warning_level > _warning_level:
                    _warning_level = mh.warning_level

        for mf in malicious_files:
            if _ip == mf.srcip or _ip == mf.dstip:
                _malicious_files.append(mf)
                if mf.warning_level > _warning_level:
                    _warning_level = mf.warning_level

        for ip in _related_urls:
            _relationships.append(hosts[ip])

        pcapAnalysis.append(PcapAnalyzer(_ip,
                                         _mac_addr,
                                         _hostname,
                                         _relationships,
                                         _malicious_files,
                                         _warning_level))
        resp += "\n{} ({}) has warning level {}".format(_hostname,
                                                          _ip,
                                                          _warning_level)
        if _warning_level != 0:
            bad_cons = len(_malicious_cons)
            bad_files = len(_malicious_files)
            if bad_cons > 0:
                resp += "\n  Connected to {} malicious hosts:".format(bad_cons)
                for mc in _malicious_cons:
                    if mc.ip == mc.hostname:
                        resp += "\n    {}".format(mc.hostname)
                    else:
                        resp += "\n    {} ({})".format(mc.hostname,
                                                       mc.ip)
            if bad_files > 0:
                resp += "\n  Downloaded {} malicious files:".format(bad_files)
                for mf in _malicious_files:
                    resp += ("\n    File: {}".format(mf.name) +
                             "\n      Type: {}".format(mf.file_type) +
                             "\n      Hash: {}".format(mf.md5_sum))

    return (resp, pcapAnalysis)
